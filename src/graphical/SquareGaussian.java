package graphical;

import java.util.ArrayList;
import java.util.Scanner;


public class SquareGaussian extends GaussianNetwork{

	public SquareGaussian(int a, int b) {
		super(a, b, REPRESENTATION.SQUARE);
	}

	
	public SquareGaussian(int a, int b, int panelW, int panelH, int factor) {
		super(a, b, panelW, panelH, factor, REPRESENTATION.SQUARE);
	}


	@Override
	protected void makeNetwork() {
		generateNodes();
		buildAdjacencyMatrix();
		setDistanceDistributions(NETWORK.GAUSSIAN);
	}


	@Override
	protected void generateNodes() {
		nodes = new ArrayList<Node>();
		for (int j = 0; j < a+b; j++){
			for (int i = -b; i <= a; i++){
				// generate node if it is within the Gaussian square
				if ( isInsideSquare(i,j)){
					nodes.add(new Node(i,j, clrDiamond));
				}
			}
		}

		// Find the index of center of the square
		// Node center = new Node((a-b)/2, (a+b)/2);
		Node center = new Node(0,0);
		centerIndex = nodes.indexOf(center);
		nodes.get(centerIndex).setColor(clrZeroNode);
		
	}


	/**
	 * Checks whether the given point is within the Gaussian square 
	 * generated by the Gaussian generator
	 * @param i	the x coordinate of the given point
	 * @param j	the y coordinate of the given point
	 * @return	true if the point is within the square
	 */
	private boolean isInsideSquare(int i, int j) {
		// check to see if the distance of the given point from the four sides
		// of the square is greater than of side length
		
		// it is better to check values in power of 2 rather than square root
		// thus, the pointToLineSquaredDistance return the distance to the power of 2
		
		// The origin is considered within the square
		if ( (i == 0 && j == 0) ) 
			return true;
		
		// The other three corners are not considered within the square
		if ( (i == a && j == b) || (i == a - b && j == a + b) || (i == -b && j == a))
			return false;
	
		// four double variables indicate the squared distance from the 
		// given point to each one of the four sides
		// Only points on Side1 and Side4 considered within the square
		double toSide1 = pointToLineSquaredDistance(i,j,0,0,a,b);
		if (toSide1 == 0) // the point is on the Side1
			return true;		
		if (Double.compare(toSide1, norm) > 0 )
			return false;

		double toSide2 = pointToLineSquaredDistance(i,j,a,b,a-b,a+b);
		if (toSide2 == 0) // the point is on the Side2
			return false;
		if (Double.compare(toSide2, norm) > 0)
			return false;

		double toSide3 = pointToLineSquaredDistance(i,j,a-b,a+b,-b,a);
		if (toSide3 == 0) // the point is on the Side3
			return false;
		if (Double.compare(toSide3, norm) > 0)
			return false;

		double toSide4 = pointToLineSquaredDistance(i,j,-b,a,0,0);
		if (toSide4 == 0) // the point is on the Side4
			return true;
		if (Double.compare(toSide4, norm) > 0)
			return false;

		// the point is not on any side and its distance to the four
		// sides of the square is less than the square's length
		return true;
	}


	/**
	 * Calculates the distance^2 between a node and a line represented by two points
	 * @param x0	the x coordinate of the given point
	 * @param y0	the Y coordinate of the given point
	 * @param x1	the x coordinate of the first point in line
	 * @param y1	the Y coordinate of the first point in line
	 * @param x2	the x coordinate of the second point in line
	 * @param y2	the y coordinate of the second point in line
	 * @return
	 */
	private double pointToLineSquaredDistance(int x0, int y0, int x1, int y1, int x2,
			int y2) {
		double numerator = Math.pow((y1-y2)*x0 + (x2-x1)*y0 + x1*y2 - x2*y1,2);
		double denominator = Math.pow(y1-y2, 2)+Math.pow(x2-x1, 2);
		return numerator / denominator;
	}
	
	

	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		System.out
				.println("Please enter a and b for the Gaussian network generator: ");

		GaussianNetwork squareGaussian =  new SquareGaussian(scan.nextInt(),
				scan.nextInt());

		squareGaussian.printNodes(NETWORK.GAUSSIAN);

		squareGaussian.printAdjacencyMatrix();
	}


}
