package graphical;

import java.awt.Color;
import java.awt.Graphics2D;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;


// So far we have implemented two ways to represent a Gaussian network
enum REPRESENTATION {
	DIAMOND, SQUARE
}

/**
 * General Gaussian network generated by alpha = a + bi (a <= b)
 * @author Arash Shamaei
 * 
 */
public abstract class GaussianNetwork {

	// Gaussian network parameters
	protected int a;
	protected int b;
	protected int t;
	protected int d;
	protected int norm; // number of nodes
	protected boolean isNormEven;
	protected REPRESENTATION representation;

	protected static final Color clrZeroNode = Color.black;
	protected static final Color clrDiamond = Color.orange;
	protected static final Color clrLines = Color.red;
	protected static final Color clrTriangles = Color.green;
	protected static final Color clrEvenNode = Color.magenta;
	protected static final Color clrDiameter = Color.cyan;

	protected int lastX;
	protected int lastY;

	protected int[] weightDistribution;

	protected List<Node> nodes;

	protected int[][] adjacencyMatrix;

	protected Node[] alpha = new Node[8];

	protected int centerIndex;

	protected List<Integer> distanceDistributions;

	/**
	 * empty constructor
	 */
	public GaussianNetwork() {

	}

	/**
	 * The constructor for console display
	 * 
	 * @param a
	 *            the gaussian network parameter a
	 * @param b
	 *            the gaussian network parameter b
	 * @param representation
	 *            the guassian network representation which is either square or
	 *            diamond
	 */
	public GaussianNetwork(int a, int b, REPRESENTATION representation) {
		this.a = a;
		this.b = b;
		this.representation = representation;
		initialize();
		makeNetwork();
	}

	/**
	 * The constructor for graphical display
	 * 
	 * @param a
	 *            the gaussian network parameter a
	 * @param b
	 *            the gaussian network parameter b
	 * @param panelW
	 *            the width of the graphical panel
	 * @param panelH
	 *            the height of the graphical panel
	 * @param factor
	 *            the magnification factor
	 * @param representation
	 *            the guassian network representation which is either square or
	 *            diamond
	 */
	public GaussianNetwork(int a, int b, int panelW, int panelH, int factor,
			REPRESENTATION representation) {
		this.a = a;
		this.b = b;
		this.representation = representation;
		initialize();
		makeNetwork();
		setNodesPanelSides(panelW, panelH, factor);
	}

	// methods called from constructor should generally be declared final
	/**
	 * Initialize the network including set the networks parameters
	 */
	private final void initialize() {
		// a <= b
		if (a > b && representation.equals(REPRESENTATION.DIAMOND)) {
			System.err.println("a should be less than or equal to b");
			System.exit(0);
		}

		// Set the eight alpha
		alpha[0] = new Node(a, b); // alpha
		alpha[1] = new Node(-b, a); // i * alpha
		alpha[2] = new Node(-a, -b); // i^2 * alpha
		alpha[3] = new Node(b, -a); // i^3 * alpha
		alpha[4] = new Node(a + b, -a + b); // alpha + i^3 * alpha = (1-i)alpha
		alpha[5] = new Node(a - b, a + b); // i * alpha + alpha = (1+i)alpha
		alpha[6] = new Node(-a - b, a - b); // i^2 * alpha + i * alpha =
											// (-1+i)alpha
		alpha[7] = new Node(-a + b, -a - b); // i^3 * alpha + i^2 * alpha =
												// (-1-i)alpha

		// Set the network's parameters
		norm = a * a + b * b;
		isNormEven = (norm % 2 == 0) ? true : false;
		if (isNormEven) {
			t = (a + b) / 2;
			d = b;
		} else {
			t = (a + b - 1) / 2;
			d = b - 1;
		}

		adjacencyMatrix = new int[norm][4];

		weightDistribution = new int[d + 1];

		System.out.println("Gaussian network with parameters: ");
		System.out.printf("alpha=%d+%di  d=%d  t=%d  Norm=%d \n", a, b, d, t,
				norm);
	}

	/**
	 * make the network by calling the appropriate methods
	 */
	protected abstract void makeNetwork();

	/**
	 * generate the nodes of the network based on different representation
	 */
	protected abstract void generateNodes();

	/**
	 * Build the adjacency matrix representing the network. The number of rows
	 * are the same as the number of nodes. There are four columns since Gaussian
	 * network is degree 4 Later, we prune this matrix to represent degree 3
	 * network
	 */
	public void buildAdjacencyMatrix() {
		for (int i = 0; i < nodes.size(); i++) {
			for (int j = 0; j < 4; j++) {
				adjacencyMatrix[i][j] = findNeighborIndex(nodes.get(i), j);
				nodes.get(i).setNeighbor(j, nodes.get(adjacencyMatrix[i][j]));
			}
		}
	}

	/**
	 * Find the neighbor index of the given node
	 * 
	 * @param node
	 *            : the given node
	 * @param neighborNumber
	 *            : the number of required neighbor Each node has four neighbors
	 *            that their addresses differ by node in +-1, +-i which is in
	 *            the order of its neighbors.
	 * @return the index of the neighbor of the node
	 */
	private int findNeighborIndex(Node node, int neighborNumber) {
		int x = 0, y = 0, neighborIndex;

		switch (neighborNumber) {
		case 0:
			x = node.x + 1;
			y = node.y;
			break;
		case 1:
			x = node.x - 1;
			y = node.y;
			break;
		case 2:
			x = node.x;
			y = node.y + 1;
			break;
		case 3:
			x = node.x;
			y = node.y - 1;
			break;
		default:
			System.err.println("The neighbor index is out of range");
			System.exit(1);
			break;
		}

		Node neighbor = new Node(x, y);
		neighborIndex = nodes.indexOf(neighbor);
		// if neighbor exists return its index
		// it means the current node is not a boundary node
		if (neighborIndex >= 0)
			return neighborIndex;

		// The current node is a boundary node because one
		// (or more) of its neighbors does not exist in the network
		int neighborNorm = neighbor.norm();
		node.setNodeType(NODE_TYPE.BOUNDARY);

		// find the neighbor modulo alpha
		// loop through all 8 alpha's
		for (int i = 0; i < 8; i++) {
			neighbor = new Node(x - alpha[i].x, y - alpha[i].y);

			// this if statement has to be run only for DiamondGaussian
			if (representation.equals(REPRESENTATION.DIAMOND)) {
				if (neighbor.norm() > neighborNorm) {
					// The neighbor corresponding neighbor should have the same
					// norm
					continue;
				}
			}
			neighborIndex = nodes.indexOf(neighbor);
			if (neighborIndex >= 0)
				return neighborIndex;
		}

		System.err.println("current node is " + node + "  neighbor is " + x
				+ ":" + y + " neighbor norm " + neighborNorm);
		return -1;
	}

	/**
	 * Consider the adjacency matrix as a graph whose center is specified by
	 * centerIndex. Running a modified version of BFS algorithm on this graph and
	 * updating the distance of nodes at each level of graph gives the updated
	 * distance for all nodes.
	 */
	public void setDistanceDistributions(NETWORK network) {
		// queue for performing BFS algorithm
		Queue<Integer> queue = new LinkedList<Integer>();

		distanceDistributions = new ArrayList<Integer>();

		// add the center to the queue
		queue.add(centerIndex);
		nodes.get(centerIndex).setVisited(true);
		distanceDistributions.add(1);

		int curLevel = 1; // number of nodes in the current level of graph
		int nextLevel = 0; // number of nodes in the next level of graph
		int weight = 1; // weight which equals the distance from the origin

		// loop the queue until it is not empty and visited all the nodes
		while (!queue.isEmpty()) {
			// if all the nodes in the current level are processed, continue to
			// next level
			if (curLevel == 0) {
				curLevel = nextLevel;
				nextLevel = 0;
				weight++;
				distanceDistributions.add(curLevel);
			}

			// get the element from the head of queue
			int cur = queue.remove();
			curLevel--;

			// loop through the neighbors of current node
			for (int i = 0; i < 4; i++) {
				// get the neighbor index
				int neighbor = adjacencyMatrix[cur][i]; 

				// if the neighbor is not the pruned one
				if (neighbor >= 0) {
					// if the neighbor is not visited yet
					if (!nodes.get(neighbor).isVisited()) {
						queue.add(neighbor); // add neighbor to queue
						
						// set it as visited
						nodes.get(neighbor).setVisited(true); 
						
						// update its weights
						nodes.get(neighbor).setWeight(weight, network); 
						
						nextLevel++; // add number of nodes for next level
					}
				}
			}
			
		}

		// make nodes unvisited after running this BFS algorithm
		// so that other call to this function doesn't have any problem
		for (Node node : nodes) {
			node.setVisited(false);
		}

	}

	public void printAdjacencyMatrix() {
		for (int i = 0; i < nodes.size(); i++) {
			System.out.printf("%8s:", nodes.get(i));
			for (int j = 0; j < 4; j++) {
				if (adjacencyMatrix[i][j] >= 0)
					System.out.printf("%8s", nodes.get(adjacencyMatrix[i][j]));
				else
					System.out.printf("        ");
			}
			System.out.println();
		}
	}

	/**
	 * Set the panel size for all the nodes in the network
	 */
	private void setNodesPanelSides(int panelW, int panelH, int factor) {
		// shifts use in square representation only to adjust the shape
		int shiftX = (a - b) / 2;
		int shiftY = (a + b) / 2;

		for (Node node : nodes) {
			node.setPanelH(panelH);
			node.setPanelW(panelW);
			node.setFactor(factor, representation, shiftX, shiftY);
		}
	}

	/**
	 * Draw all the nodes in the network
	 * 
	 * @param g2d
	 * @param isWraparound 
	 */
	public void doDrawing(Graphics2D g2d, boolean isWraparound) {
		
		// drawing three other centers for square representation
		// just for drawing purposes
		if ( representation.equals(REPRESENTATION.SQUARE)){
			int shiftX = (a - b) / 2;
			int shiftY = (a + b) / 2;

			nodes.add(new Node(a,b, clrEvenNode, shiftX, shiftY, nodes.get(0), DEGREE.FOUR));
			nodes.add(new Node(a-b, a+b, clrEvenNode, shiftX, shiftY, nodes.get(0), DEGREE.FOUR));
			nodes.add(new Node(-b, a, clrEvenNode, shiftX, shiftY, nodes.get(0), DEGREE.FOUR));
		}

		for (Node node : nodes) {
			node.doDrawing(g2d, NETWORK.GAUSSIAN);
			if (isWraparound){
				node.drawWraparounds(g2d, NETWORK.GAUSSIAN);
			}
		}
	}
	

	public void printNodes(NETWORK network) {
		Node curPoint;
		int curIndex;

		for (int j = (a + b); j >= -(a + b); j--) {
			for (int i = -(a + b); i <= (a + b); i++) {
				curPoint = new Node(i, j); // a temporary object for indexing
											// the list
				curIndex = nodes.indexOf(curPoint);
				if (curIndex >= 0) {
					System.out.printf("%3d",
							nodes.get(curIndex).getWeight(network)); 
					// System.out.print(nodes.get(curIndex));
				} else {
					System.out.printf("   "); // just print the space
				}
			}
			System.out.println();
		}

	}

	public int getT() {
		return t;
	}

	public int getD() {
		return d;
	}

	public int getNorm() {
		return norm;
	}

	public void setDifference() {
		// to be used by HoneyComb only
	}

	public void setNodeDegrees() {
		// to be used by HoneyComb only
	}

	public List<Node> getNodes() {
		return nodes;
	}

}
